#!/usr/bin/env bash
set -euo pipefail

TEST_DIR="test"
DEFAULT_ENV_DIR="env/default"

mkdir -p "$TEST_DIR"
mkdir -p "$DEFAULT_ENV_DIR"

cat > "${TEST_DIR}/steps.go" <<'EOF'
/*
{{#appName}}
{{{.}}}
{{/appName}}

Testing {{classname}}Service

*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech);

package {{packageName}}

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"reflect"
	"strconv"

    "github.com/getgauge-contrib/gauge-go/gauge"
    m "github.com/getgauge-contrib/gauge-go/models"
	. "github.com/getgauge-contrib/gauge-go/testsuit"
	{{goImportAlias}} "{{gitHost}}/{{gitUserId}}/{{gitRepoId}}{{#isGoSubmodule}}/{{packageName}}{{/isGoSubmodule}}"
)

type request struct {
    Classname string
	OperationId string
	Parameters map[string]any
}

type feature struct {
	APIClient *{{goImportAlias}}.APIClient
	Request *request
	Response *http.Response
}

func (f *feature) createARequestForTheApi(operationId string, classname string) {
	f.Request = &request {
        Classname: classname,
		OperationId: operationId,
		Parameters:  make(map[string]any),
	}
}

func (f *feature) giveTheParameterAValueOf(param string, val string) {
    {{#apiInfo.apis}}
    if f.Request.Classname == "{{#lambda.pascalcase}}{{#lambda.snakecase}}{{classname}}{{/lambda.snakecase}}{{/lambda.pascalcase}}" {
        {{#operations}}
        {{#operation}}
        if f.Request.OperationId == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}" {
            {{#allParams}}
            if param == "{{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}}" {
                conv, err := convertTo[{{#isModel}}{{goImportAlias}}.{{/isModel}}{{{dataType}}}](val)
                if err != nil {
                    T.Fail(err)
                    return
                }

                f.Request.Parameters["{{paramName}}"] = conv
	            return
            }
            {{^-last}}

            {{/-last}}
            {{/allParams}}
        }
        {{^-last}}

        {{/-last}}
        {{/operation}}
        {{/operations}}
    }

    {{/apiInfo.apis}}
    T.Fail(fmt.Errorf("%s.%s does not have a parameter called %s", f.Request.Classname, f.Request.OperationId, param))
}

func (f *feature) giveTheParameterAJsonValueOf(param string, val string) {
    {{#apiInfo.apis}}
    if f.Request.Classname == "{{#lambda.pascalcase}}{{#lambda.snakecase}}{{classname}}{{/lambda.snakecase}}{{/lambda.pascalcase}}" {
        {{#operations}}
        {{#operation}}
        if f.Request.OperationId == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}" {
            {{#allParams}}
            if param == "{{paramName}}" {
                var obj {{#isModel}}{{goImportAlias}}.{{/isModel}}{{{dataType}}}
                err := json.Unmarshal([]byte(val), &obj)
                if err != nil {
                    T.Fail(err)
                    return
                }

                f.Request.Parameters["{{paramName}}"] = obj
                return
            }
            {{^-last}}

            {{/-last}}
            {{/allParams}}
        }
        {{^-last}}

        {{/-last}}
        {{/operation}}
        {{/operations}}
    }

    {{/apiInfo.apis}}
    T.Fail(fmt.Errorf("%s.%s does not have a parameter called %s", f.Request.Classname, f.Request.OperationId, param))
}

func (f *feature) giveTheParameterTheFollowingValues(param string, table *m.Table) {
    {{#apiInfo.apis}}
    if f.Request.Classname == "{{#lambda.pascalcase}}{{#lambda.snakecase}}{{classname}}{{/lambda.snakecase}}{{/lambda.pascalcase}}" {
        {{#operations}}
        {{#operation}}
        if f.Request.OperationId == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}" {
            {{#allParams}}
            if param == "{{paramName}}" {
                {{#isContainer}}
                slice := []{{{baseType}}}{}
                for _, row := range table.Rows {
                    val, err := convertTo[{{{baseType}}}](row.Cells[0])
                    if err != nil {
                        T.Fail(err)
                        return
                    }

                    slice = append(slice, val)
                }

                f.Request.Parameters["{{paramName}}"] = slice
                return
                {{/isContainer}}
                {{^isContainer}}
                T.Fail(errors.New("cannot read a Table into parameter {{#lambda.camelcase}}{{paramName}}{{/lambda.camelcase}} as it is not an array"))
                return
                {{/isContainer}}
            }
            {{^-last}}

            {{/-last}}
            {{/allParams}}
        }
        {{^-last}}

        {{/-last}}
        {{/operation}}
        {{/operations}}
    }

    {{/apiInfo.apis}}
    T.Fail(fmt.Errorf("%s.%s does not have a parameter called %s", f.Request.Classname, f.Request.OperationId, param))
}

func (f *feature) sendTheRequest() {
    {{#apiInfo.apis}}
    if f.Request.Classname == "{{#lambda.pascalcase}}{{#lambda.snakecase}}{{classname}}{{/lambda.snakecase}}{{/lambda.pascalcase}}" {
        {{#operations}}
        {{#operation}}
        if f.Request.OperationId == "{{#lambda.camelcase}}{{operationId}}{{/lambda.camelcase}}" {
            {{#pathParams}}
            var {{paramName}}Param any
            {{#-last}}

            {{/-last}}
            {{/pathParams}}
            {{#pathParams}}
            if val, ok := f.Request.Parameters["{{paramName}}"]; ok {
                {{paramName}}Param = val
            } else {
                T.Fail(errors.New("parameter \"{{paramName}}\" is required"))
                return
            }

            {{/pathParams}}
            request := f.APIClient.{{classname}}.{{operationId}}(context.Background(){{#pathParams}}, safeCast[{{#isModel}}{{goImportAlias}}.{{/isModel}}{{{dataType}}}]({{paramName}}Param){{/pathParams}})
            
            {{#allParams}}
            {{^isPathParam}}
            if val, ok := f.Request.Parameters["{{paramName}}"]; ok {
                request = request.{{#lambda.pascalcase}}{{paramName}}{{/lambda.pascalcase}}(safeCast[{{#isModel}}{{goImportAlias}}.{{/isModel}}{{{dataType}}}](val))
            }

            {{/isPathParam}}
            {{/allParams}}
            {{#returnType}}_, {{/returnType}}response, err := request.Execute()
            if err != nil {
                T.Fail(err)
                return
            }

            f.Response = response
        }
        {{^-last}}

        {{/-last}}
        {{/operation}}
        {{/operations}}
    }

    {{/apiInfo.apis}}
}

func (f *feature) theResponseStatusShouldBe(statusCode string) {
	sc, err := strconv.ParseInt(statusCode, 10, 32)
	if err != nil {
		T.Fail(err)
		return
	}

	if int(sc) != f.Response.StatusCode {
		T.Fail(fmt.Errorf("expected statusCode to be %d, but got %d", sc, f.Response.StatusCode))
	}
}

func convertTo[T any](val string) (T, error) {
	var zero T
	toType := reflect.TypeOf(zero)

	if toType == reflect.TypeOf("") {
		return any(val).(T), nil
	} else if toType == reflect.TypeOf(int32(0)) {
		i, err := strconv.ParseInt(val, 10, 32)
		return any(int32(i)).(T), err
	} else if toType == reflect.TypeOf(int64(0)) {
		i, err := strconv.ParseInt(val, 10, 64)
		return any(int64(i)).(T), err
	} else if toType == reflect.TypeOf(float32(0)) {
		f, err := strconv.ParseFloat(val, 32)
		return any(float32(f)).(T), err
	} else if toType == reflect.TypeOf(float64(0)) {
		f, err := strconv.ParseFloat(val, 64)
		return any(float64(f)).(T), err
	} else if toType == reflect.TypeOf(false) {
		b, err := strconv.ParseBool(val)
		return any(b).(T), err
	}

	return zero, fmt.Errorf("cannot convert from str to %s", toType.Name())
}

func safeCast[T any](value interface{}) T {
	var zero T
    
	if value == nil {
        return zero
    }

    if casted, ok := value.(T); ok {
        return casted
    }

    return zero
}

func init() {
	configuration := {{goImportAlias}}.NewConfiguration()
	configuration.Scheme = "http"
	configuration.Host = "localhost:4010"
	feat := &feature {
		APIClient: {{goImportAlias}}.NewAPIClient(configuration),
	}

    gauge.Step("Create a <operationId> request for the <classname>", feat.createARequestForTheApi)
    gauge.Step("Create an <operationId> request for the <classname>", feat.createARequestForTheApi)
    gauge.Step("Give the <parameter> parameter a value of <value>", feat.giveTheParameterAValueOf)
    gauge.Step("Give the <parameter> parameter a JSON value of <value>", feat.giveTheParameterAJsonValueOf)
    gauge.Step("Give the <parameter> parameter the following values: <table>", feat.giveTheParameterTheFollowingValues)
    gauge.Step("Send the request", feat.sendTheRequest)
    gauge.Step("The response status should be <statusCode>", feat.theResponseStatusShouldBe)
}
EOF

cat > "manifest.json" <<EOF
{
  "Language": "go",
  "Plugins": [
    "html-report"
  ],
  "step_impl_dir": "${TEST_DIR}"
}
EOF

cat > "${DEFAULT_ENV_DIR}/default.properties" <<'EOF'
# default.properties
# properties set here will be available to the test execution as environment variables

# sample_key = sample_value

#The path to the gauge reports directory. Should be either relative to the project directory or an absolute path
gauge_reports_dir = reports

#Set as false if gauge reports should not be overwritten on each execution. A new time-stamped directory will be created on each execution.
overwrite_reports = true

# Set to false to disable screenshots on failure in reports.
screenshot_on_failure = true

# The path to the gauge logs directory. Should be either relative to the project directory or an absolute path
logs_directory = logs

# The path the gauge specifications directory. Takes a comma separated list of specification files/directories.
gauge_specs_dir = specs

# The default delimiter used read csv files.
csv_delimiter = ,

# Allows steps to be written in multiline
allow_multiline_step = false
EOF

cat > "${DEFAULT_ENV_DIR}/go.properties" <<EOF
# Configuring the Go step implementation
gauge.go.package=main

# Optional: Set the GOPATH if it's not already set in your environment
#gauge.go.gopath=/path/to/your/gopath

# Customizing the way Gauge runs Go step implementations
gauge.go.timeout=10s
EOF